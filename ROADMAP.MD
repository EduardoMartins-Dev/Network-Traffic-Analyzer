üó∫Ô∏è Roadmap: Network Traffic Analyzer (Enterprise Architecture)
Este documento descreve o plano de evolu√ß√£o do projeto, focado em alta performance e desacoplamento de servi√ßos usando Arquitetura Orientada a Eventos (EDA).

üèÅ Fase 1: Funda√ß√£o e Captura (The Sniffer)
Objetivo: Estabelecer o ambiente e garantir que o C "enxerga" a rede (Libpcap).

[ ] Configura√ß√£o do Lab:

[ ] Subir VM Kali Linux (Monitor) e VM Alvo.

[ ] Garantir conectividade isolada (Host-only/NAT Network).

[ ] Hello World Libpcap:

[ ] Inicializar dispositivo de rede em modo prom√≠scuo.

[ ] Loop de captura simples (pcap_loop).

[ ] Imprimir mensagem no terminal a cada pacote recebido.

[ ] Filtros BPF:

[ ] Aplicar filtros para ignorar tr√°fego SSH (porta 22) e focar em TCP/UDP/ICMP.

üß† Fase 2: O Motor de An√°lise (Protocol Dissector)
Objetivo: Traduzir bytes brutos (Raw Data) em informa√ß√µes estruturadas.

[ ] Estruturas de Dados (Structs):

[ ] Mapear cabe√ßalho Ethernet (MAC Address).

[ ] Mapear cabe√ßalho IP (IP Src/Dst, TTL, Protocolo).

[ ] Mapear cabe√ßalho TCP/UDP (Portas, Flags).

[ ] Aritm√©tica de Ponteiros:

[ ] Implementar l√≥gica para "pular" cabe√ßalhos e ler o payload.

[ ] Extrair dados: [TCP] 192.168.1.5:443 -> 192.168.1.10:55432.

üêá Fase 3: Camada de Mensageria & Serializa√ß√£o (Middleware)
Objetivo: Desacoplar a captura do armazenamento. O Sniffer n√£o grava no banco, ele apenas "avisa" a fila.

[ ] Infraestrutura RabbitMQ:

[ ] Adicionar RabbitMQ ao docker-compose.yml.

[ ] Configurar Exchange e Queue (network_events).

[ ] Serializa√ß√£o de Dados (C para JSON):

[ ] Integrar biblioteca cJSON ou Jansson no projeto C.

[ ] Criar fun√ß√£o packet_to_json(): Converter a struct do pacote em string JSON.

[ ] Conector AMQP (C Client):

[ ] Integrar biblioteca rabbitmq-c (librabbitmq).

[ ] Implementar conex√£o persistente com o Broker.

[ ] Publicar JSON na fila a cada pacote processado.

‚öôÔ∏è Fase 4: O Consumidor e Persist√™ncia (The Worker)
Objetivo: Ler da fila em alta velocidade e gravar no banco de dados.

[ ] Worker Service (Python/Go/Telegraf):

[ ] Criar um script/servi√ßo separado que escuta a fila do RabbitMQ.

[ ] Nota: Isso tira o peso de I/O (Input/Output) do programa em C principal.

[ ] Banco de Dados (Time Series):

[ ] Configurar InfluxDB via Docker.

[ ] Implementar escrita em lote (Batch Write) para performance.

[ ] Gravar m√©tricas: bytes_sent, packets_count, flags_detected.

üìä Fase 5: Visualiza√ß√£o e Opera√ß√£o (SOC Dashboard)
Objetivo: Transformar dados em intelig√™ncia visual.

[ ] Grafana Setup:

[ ] Conectar Grafana ao InfluxDB.

[ ] Dashboards Operacionais:

[ ] Veloc√≠metro: Throughput da rede em tempo real (MB/s).

[ ] Top Talkers: Quem s√£o os IPs que mais geram tr√°fego?

[ ] Mapa de Calor: Portas mais acessadas.

[ ] Indicador de Amea√ßas: Contagem de pacotes suspeitos.

üõ°Ô∏è Fase 6: Intelig√™ncia de Seguran√ßa (IDS Engine)
Objetivo: An√°lise comportamental para detec√ß√£o de intrus√£o.

[ ] An√°lise de Flags TCP:

[ ] Detectar anomalias (Ex: Null Scan, Xmas Scan).

[ ] Detector de Port Scan:

[ ] L√≥gica temporal: "Se IP X acessar > 10 portas em < 1s -> ALERTA".

[ ] Publicar alerta em uma fila separada (security_alerts).

[ ] Detector de DoS (Syn Flood):

[ ] Calcular raz√£o SYN/ACK. Desbalanceamento indica ataque.

[ ] Logging de Alerta:

[ ] Enviar notifica√ß√£o cr√≠tica (Log ou Webhook).
